/*
 * 城情報型 及び、 城付加情報型
 */
#pragma once
#pragma pack(1)

#include <windows.h>

using namespace std;

/*
			城情報(33*214)

			[33バイト]

			0-1		軍団所属リストの前
			2-3		リストの後ろ
			4-5		城主
			6-7		浪人先頭
			8-16	城名
			17-18	所属	所属軍団の軍団番号
			19		城郭
			20-21	石高
			22		商業
			23-24	人口-徴兵可
			25		民忠
			26-27	徴兵可
			28		兵質 0-2
			29		ABC0 EFGH
					A 一揆 B 国際港 C 港 E 馬産地 F 鍛冶 G 本城 H 居城
			30		ABCD EFGH
					C 一揆扇動 G 金山 H 銀山
			31		AAAAAA BB
					A:城称	0x00 城 0x01 御坊 0x02 寺 0x04 御所 0x08 館 0x10 町 0x20 城、それ以外の値=何も付かない
					B:｢絵｣を表示した時の、背景の種類(0=山) (1=林) (2=海) (3=平野)
			32		000A000B A-巨城 B 名前変更
*/
struct 城情報型
{
	WORD 前の城【城番号】;			// あまり使うことはない  軍団所属城リスト 前の城
	WORD 次の城【城番号】;			// とくに使うことはない  軍団所属城リスト 後の城
	WORD 城主【武将番号】;			// 城主
	WORD _浪人先頭武将【武将番号】;	// あまり使うことはない

	char _城名[9];				//城名
	WORD 所属軍団【軍団番号】;	//所属軍団番号
	byte 城郭;			//城郭
	WORD 石高;			//石高
	byte 商業;			//商業
	WORD 人口;			//人口
	byte 民忠;			//民忠
	WORD 徴兵可;		//徴兵可

	byte 兵質;			//兵質 0-2  (悪=0, 普=1, 良=2)
	byte 本城:2;		//本城 居城 (大名の本城=1, 軍団長の居城=2)
	byte 鍛冶:1;		//鍛冶
	byte 馬産地:1;		//馬産地
	byte _未定義3:1;	//0
	byte 港:1;			//港
	byte 国際港:1;		//国際港
	byte _未定義4:1;	//
	byte 銀山:1;		//銀山
	byte 金山:1;		//金山
	byte _未定義5:2;	//
	byte 一騎煽動:1;	//一揆扇動
	byte _未定義6:3;	//

	byte 城絵背景:2;	//｢絵｣を表示した時の、背景の種類 城称(0=山) (1=林) (2=海) (3=平野)
	byte _城称:6;		// ここの情報はGet_城称(...)で得ること。
	byte _未定義7:3;	//
	byte 巨城:1;		//巨城
	byte _名前変更:4;	//あまり使うことはない 名前変更 シナリオエディタか何かに詳しく説明があったようななかったような…
};


namespace 関数 {


	// 城名を取得する
	string Get_城名( int 城番号【配列用】);

	// 城名を設定する
	void   Set_城名( int 城番号【配列用】, string 城名 );

	// 「城・御所・館」といったような、城名に付ける城称の文字列を得ることができる。
	string Get_城称(int 城番号【配列用】);

	// 城名から城番号を得る。｢◎◎城」や「▲▲寺」などの◎◎、▲▲に相当する、名前本体部分のみ指定すること。
	// 城が存在しない時には0xFFFFが返ってくる。
	int Get_城番号【配列用】( string 城名 );

	// 指定の軍団が所持している城数
	int Get_軍団所持城数(int 軍団番号【配列用】);

	// 指定の大名が所持している城の数。
	int Get_大名所持城数(int 大名番号【配列用】);

}


// 値比較用
namespace 城絵背景 {
	enum { 山=0, 林=1, 海=2, 平野=3 };
};

// 値比較用
namespace 兵質 {
	enum { 悪=0, 普=1, 良=2 };
}


/*
			城の位置情報など(8*214)

			[8バイト]

			0	地域名
			1	0
			2	石高最大値/10
			3	商業最大値
			4	Xセル座標(マップで見えてるのとは異なる区切り方 50個で区切られている)
			5	Yセル座標(上と同じで、マップで見えているのとは異なる区切り方12個程度で区切られている)
			6	X_offset
			7	Y_offset
*/
struct 城付加情報型
{
    byte 所属地域【地域番号】;	//地域名
	byte _未定義1;			//must 0
	byte 最大石高÷10;		//最石高÷10
	byte 最大商業値;		//最商業
	byte _Ｘ情報;			//やや不透明。セルX関連の情報    Ｘは３違いぐらいでも隣接していることがある。２以下は確実に隣接している。
	byte _Ｙ情報;			//やや不透明。セルY関連の情報	 Ｙは２以下なら隣接している。
	byte Ｘ位置;			//城のＸ位置。この情報はかなり固い。グリッドマップを導入すればよくわかる。グリッド内のＸ幅は５（うち４つが使え、１つは境界線上）
	byte Ｙ位置;			//城のＹ位置。この情報はかなり固い。グリッドマップを導入すればよくわかる。グリッド内のＹ幅は３．
};

namespace 関数 {
	void Set_城位置(int 城番号【配列用】, int Ｘ位置, int Ｙ位置);
}



/*
 以下、メインマップのグリッド線で区切られた城グリッドの位置の計算
 */

// メインマップのグリッド用の構造体。
// Get_城グリッド位置 関数の 返り値として利用される。
struct 城グリッド位置型 {
	int Ｘ;
	int Ｙ;
	城グリッド位置型(int _x,int _y);
	城グリッド位置型() : Ｘ(0),Ｙ(0) {}

	WORD 北西【城番号】; // 存在しない時は、0xFFFF;
	WORD 北【城番号】;   // 存在しない時は、0xFFFF;
	WORD 北東【城番号】; // 存在しない時は、0xFFFF;
	WORD 西【城番号】;   // 存在しない時は、0xFFFF;
	WORD 東【城番号】;   // 存在しない時は、0xFFFF;
	WORD 南西【城番号】; // 存在しない時は、0xFFFF;
	WORD 南【城番号】;   // 存在しない時は、0xFFFF;
	WORD 南東【城番号】; // 存在しない時は、0xFFFF;
};

// グリッドの方向ベクトル
struct 城グリッドベクトル型 {
	int Ｘ;
	int Ｙ;
	城グリッドベクトル型(int Ｘ成分, int Ｙ成分) : Ｘ(Ｘ成分),Ｙ(Ｙ成分) {}
	城グリッドベクトル型() : Ｘ(0),Ｙ(0) {}
};

namespace 関数 {

	// 城ＩＤから、メイングリッド上のポジションを得る。左上グリッドが0,0。mapdataobgkのグリッドを見ればわかりやすい。
	// 上が０で下にいくほど数値が増えるので、ベクトルとは南北が逆なので注意すること。
	// １つのグリッドには、１つの城しかない。
	城グリッド位置型 Get_城グリッド位置(int 城番号【配列用】);


	// グリッド座標同志の減算。座標Ａ→座標Ｂのベクトルを求めるのに、通常、Ｂ−Ａをするだろうから。
	城グリッドベクトル型 operator-(城グリッド位置型 &p1, 城グリッド位置型 &p2);

	// ２つの城のグリッド位置が、隣接位置かどうか。
	bool Is_隣接城( int 城Ａ番号【配列用】, int 城Ｂ番号【配列用】);
	bool Is_隣接城( 城グリッド位置型 &位置１, 城グリッド位置型 &位置２);


}



