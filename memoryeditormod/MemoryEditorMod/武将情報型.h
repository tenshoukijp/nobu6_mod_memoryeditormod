/*
 * 武将情報型 及び、 武将戸籍情報型
 */
#pragma once
#pragma pack(1)

#include <windows.h>


/*
【武将の思考アルゴリズム】:
0…名将と呼ばれた人物。有名武将に多い。信長秀吉家康ほか、斎藤道三や松永久秀も。
  総合的なバランスの良いタイプだが、comの場合兵力ばかり増やし、あまり戦争しない。
1…猛将に多い。柴田勝家や柿崎景家や南部晴政ら。
2…戦闘に強い武将が多い。剣豪など。
3…戦闘嫌い。今川氏真ら。政治好き？
4…板部岡江雪等、坊主・茶人等の文化人系武将。政治好き？
5…忍者武将や、久武親直・金地院崇伝など。調略好き。
6…目立たないザコ武将。無能タイプ？
7…オリジナル姫。性格は不明。
255…ランダム姫。性格は不明。
*/

/*
【口調】:
0 無口			 217 真田幸村・長宗我部元親・島津義久・忍者全員 
1 礼儀正しい	 152 前田利家・明智光秀・立花宗茂・徳川光圀 
2 粗暴			 119 柴田勝家・龍造寺隆信・可児才蔵・佐々木小次郎 
3 高貴			 30 上杉憲政・今川義元・足利義晴・一条兼定 
4 生意気		 180 伊達政宗・三好長慶・鈴木重秀・由比正雪 
5 威厳			 143 織田信長・徳川家康・武田信玄・上杉謙信 
6 饒舌			 145 豊臣秀吉・斎藤道三・松永久秀・足利義昭 
7 一般			 314 本多忠勝・吉川元春・山中鹿之助・史実姫全員 
*/

/*
			[武将データ(47*532)]

			0-1	前の武将
			2-3 後ろの武将
			4-5	？
			6	政才
			7	戦才
			8	智才
			9-10	政熟 ( min 500 〜 max 2000 )
			11-12	戦熟 ( min 500 〜 max 2000 )
			13-14	智熟 ( min 500 〜 max 2000 )
			15	魅力
			16	野望
			17	忠誠
			18-19	勲功
			20	血筋 0xFFは無縁
			21-22	大名
			23-24	軍団
			25-26	居城
			27-28	内応先 FFFF 無し
			29	兵数
			30	訓練
			31	兵忠
			32	兵態(0=足軽,1=騎馬,2=鉄砲,3=騎馬鉄砲,18まで)
			33	仕官
			34	妻 他に結婚済みフラグあり？
			35	生年
			36-37	親顔NO
			38	思考　（思考アルゴリズム）
			39	aaaabbbb a-相性 b-義理
			40	00aabbcc a-智適 b-戦適 c-政適
			41	技能
			42	職業 0x00無 0x10 忍者 0x20 茶人 0x30 剣豪 0x40 僧侶 0x50 海賊 0x60 高家 0x70 商人 0x80 庶民 0x90 切支丹 0xA0 騎士 0xB0 魔術士 0xC0 魔族
			43-44	兵科・騎馬鉄砲・大砲・鉄甲船
				0123 4445 5566 6777
				0=無関係？,1=鉄甲船,2=騎馬鉄砲,3=大砲
				4,5,6,7=水軍,鉄砲,騎馬,足軽の兵科、MAX5
			45	aabbbccc a-独立 b-勇猛 c-寿命
			46	1234aaa5 1=会見 2-遺恨 3 内応 4-行動 5独立のビットの続き
				a-口調 
*/

struct 武将情報型
{
	WORD 前の武将【武将番号】;	// あまり使うことはない
	WORD 次の武将【武将番号】;	// とくに使うことはない
	WORD _未定義1;		//must 0xFFFF
	byte 最大政才;		//政才
	byte 最大戦才;		//戦才
	byte 最大智才;		//智才
	WORD 政治熟練値;		//政熟
	WORD 戦闘熟練値;		//戦熟
	WORD 智謀熟練値;		//智熟
	char 魅力;			//魅力
	char 野望;			//野望
	char 忠誠;			//忠誠
	WORD 勲功;			//勲功
	byte 所属血筋;		//血筋番号 0xFFは無縁
	WORD 所属大名【大名番号】;	//大名
	WORD 所属軍団【軍団番号】;	//軍団
	WORD 所属居城【城番号】;	//居城
	WORD 内応先大名【大名番号】;//内応先 0xFFFFは内応していない
	byte 兵数;			//兵数
	byte 訓練;			//訓練
	byte 士気;			//兵忠
	byte 兵態;			//兵態(0=足軽,1=騎馬,2=鉄砲,3=騎馬鉄砲,18まで)
	byte 仕官年数;		//仕官年数
	byte _妻;			//妻 この番号が255なら妻はいない。255以外の時(例えば3)は、その番号に500足した【武将番号】(例えば503)の女性が妻ということ)。そして該当の武将(妻姫武将)の_妻も同じ3の値になっていること。
	byte 生年;			//生年 - 1454(天翔記基準年)
	WORD 親顔番号;		//親顔NO。セーブエディタやシナリオエディタの武将の｢顔番号｣と一致する。「kao_24bit」や「武将一覧.xls」の番号とは１つずれる(これらは１つ大きい番号)なので注意。
	byte 思考;			//思考アルゴリズム
	byte 義理:4;		//義理
	byte 相性:4;		//相性 (0-15)
						//00aa bbcc a-智適 b-戦適 c-政適
	byte 政治適性:2;	//c-政適 (2=A,1=B,0=C)
	byte 戦闘適性:2;	//b-戦適 (2=A,1=B,0=C)
	byte 智謀適性:2;	//a-智適 (2=A,1=B,0=C)
	byte _未定義2:2;	//

	byte 技能一喝:1;	//技能・一喝
	byte 技能暗殺:1;	//技能・暗殺
	byte 技能流出:1;	//技能・流出
	byte 技能煽動:1;	//技能・煽動
	byte 技能流言:1;	//技能・流言
	byte 技能弁舌:1;	//技能・弁舌
	byte 技能焼討:1;	//技能・焼討
	byte 技能挑発:1;	//技能・挑発
	byte 職業;			//職業 0x00 無 0x10 忍者 0x20 茶人 0x30 剣豪 0x40 僧侶 0x50 海賊 0x60 高家 0x70 商人 0x80 庶民 0x90 切支丹 0xA0 騎士 0xB0 魔術士 0xC0 魔族

	byte 足軽適性:3;	//足軽適性
	byte 騎馬適性:3;	//騎馬適性
	byte _鉄砲適性_hi:2;//鉄砲適性はここでは取得・設定が出来ない。Get_鉄砲適性・Set_鉄砲適性を利用すること。鉄砲適性上位ビット
	byte _鉄砲適性_lo:1;//鉄砲適性はここでは取得・設定が出来ない。Get_鉄砲適性・Set_鉄砲適性を利用すること。鉄砲適性下位ビット
	byte 水軍適性:3;	//水軍適性

	byte 大砲:1;		//大砲
	byte 騎馬鉄砲:1;	//騎馬鉄砲
	byte 鉄甲船:1;		//鉄甲船
	byte _未定義3:1;	//0
	byte 寿命:3;		//寿命
	byte 勇猛:3;		//勇猛
	byte _独立_hi:2;	//独立値はここでは取得・設定が出来ない。Get_独立・Set_独立を利用すること。独立上位ビット
	byte _独立_lo:1;	//独立値はここでは取得・設定が出来ない。Get_独立・Set_独立を利用すること。独立下位ビット
	byte 口調:3;		//口調
	byte 行動済:1;		//行動
	byte 内応状態:1;	//内応
	byte 遺恨状態:1;	//遺恨
	byte 会見済:1;		//会見
};

// 以下値比較用
namespace 兵態 {
	enum { 足軽=0, 騎馬=1, 鉄砲=2, 騎馬鉄砲=3 };
};

namespace 職業 {
	enum { 無し=0, 忍者= 0x10, 茶人=0x20, 剣豪=0x30, 僧侶=0x40, 海賊=0x50, 高家=0x60, 商人=0x70, 庶民=0x80, 切支丹=0x90, 騎士=0xA0, 魔術士=0xB0, 魔族=0xC0 }; 
};

namespace 政治適性 {
	enum { Ａ=2, Ｂ=1, Ｃ=0 };
};
namespace 戦闘適性 {
	enum { Ａ=2, Ｂ=1, Ｃ=0 };
};
namespace 智謀適性 {
	enum { Ａ=2, Ｂ=1, Ｃ=0 };
};

namespace 足軽適性 {
	enum { Ｓ=5, Ａ=4, Ｂ=3, Ｃ=2, Ｄ=1, Ｅ=0 };
};
namespace 騎馬適性 {
	enum { Ｓ=5, Ａ=4, Ｂ=3, Ｃ=2, Ｄ=1, Ｅ=0 };
};
namespace 鉄砲適性 {
	enum { Ｓ=5, Ａ=4, Ｂ=3, Ｃ=2, Ｄ=1, Ｅ=0 };
};
namespace 水軍適性 {
	enum { Ｓ=5, Ａ=4, Ｂ=3, Ｃ=2, Ｄ=1, Ｅ=0 };
};
namespace 弓適性 {
	enum { Ｓ=5, Ａ=4, Ｂ=3, Ｃ=2, Ｄ=1, Ｅ=0 };
};
namespace 槍適性 {
	enum { Ｓ=5, Ａ=4, Ｂ=3, Ｃ=2, Ｄ=1, Ｅ=0 };
};



namespace 関数 {

	// 鉄砲の適性を取得する。(0=E,1=D,2=C,3=B,4=A,5=S  足軽適性::Ｓ 〜 足軽適性::Ｅ と比較すると良い)
	int  Get_鉄砲適性( int 武将番号【配列用】);

	// 鉄砲の適性を設定する。(0=E,1=D,2=C,3=B,4=A,5=S  足軽適性::Ｓ 〜 足軽適性::Ｅ で設定すると良い)
	void Set_鉄砲適性( int 武将番号【配列用】, int 鉄砲適性値 );


	// 弓の適性を取得する。(0=E,1=D,2=C,3=B,4=A,5=S  弓適性::Ｓ 〜 弓適性::Ｅ と比較すると良い)
	int  Get_弓適性( int 武将番号【配列用】);

	// 弓の適性を設定する。(0=E,1=D,2=C,3=B,4=A,5=S  弓適性::Ｓ 〜 弓適性::Ｅ で設定すると良い)
	void Set_弓適性( int 武将番号【配列用】, int 鉄砲適性値 );

	// 槍の適性を取得する。(0=E,1=D,2=C,3=B,4=A,5=S  槍適性::Ｓ 〜 槍適性::Ｅ と比較すると良い)
	int  Get_槍適性( int 武将番号【配列用】);

	// 槍の適性を設定する。(0=E,1=D,2=C,3=B,4=A,5=S  槍適性::Ｓ 〜 槍適性::Ｅ で設定すると良い)
	void Set_槍適性( int 武将番号【配列用】, int 鉄砲適性値 );


	// 武将の独立値を取得する。
	int Get_独立( int 武将番号【配列用】);

	// 武将の独立値を設定する。
	void Set_独立( int 武将番号【配列用】, int 独立値 );


	// 武将の政治値を取得する ( 110 MAX 換算 )
	int Get_政治値( int 武将番号【配列用】);

	// 武将の戦闘値を取得する ( 110 MAX 換算 )
	int Get_戦闘値( int 武将番号【配列用】);

	// 武将の智謀値を取得する ( 110 MAX 換算 )
	int Get_智謀値( int 武将番号【配列用】);

	// 武将の最大兵数を取得する
	int Get_武将最大兵数(int 武将番号【配列用】);

	/* 
	 * 武将の｢顔番号｣から｢武将番号【配列用】｣を取得する。存在しない場合は、｢0xFFFF｣が返ってくる。
	 */
	WORD Get_武将番号【配列用】(int 顔番号);

	/* 
	 * 武将の(名字+名前)(=フルネーム)から｢武将番号【配列用】｣を取得する。存在しない場合は、｢0xFFFF｣が返ってくる。
	 */
	WORD Get_武将番号【配列用】(string 武将姓名);

	/*
	 * 武将の年齢を得る。
	 */
	int Get_武将年齢(int 武将番号【配列用】);
}



namespace 口調 {
	enum { 無口=0, 礼儀=1, 粗暴=2, 高貴=3, 生意気=4, 威厳=5, 饒舌=6, 一般=7 };
};

namespace 思考 {
	enum { 名将=0, 猛将=1, 堅剛=2, 厭戦=3, 内政=4, 調略=5, 一般=6, 姫《史実》=7, 姫《架空》=255 }; 
};

namespace 会見意向 {
	enum {
		静観=0, 開発=1, 商業=2, 築城=3, 施し=4, 戦争=5, 徴兵=6, 訓練=7, 編成兵数=8, 騎馬編成=9, 鉄砲編成=10,
		前線移動=11, 後方移動=12, 米購入=13, 鉄砲購入=14, 騎馬購入=15, 家宝購入=16, 米売却=17, 講義師範=18,
		講義習得=19, 登用=20, 昇進=21, 褒美=22, 同盟締結=23, 共同戦線=24, 友好親善=25, 手切れ=26, 脅迫=27,
		朝廷工作=28, 内応=29, 住民流出=30, 一揆扇動=31, 流言飛語=32, 焼き討ち=34, 合戦誘発=35
	};
};

namespace 関数 {
	// 対象武将の会見意向の取得
	int Get_会見意向(int 武将番号【配列用】);

	// 対象武将の会見意向の設定
	void Set_会見意向(int 武将番号【配列用】, int 会見意向);
}


namespace 関数 {
	/*
	 *相性の差分を得る。 最小0(相性最高) 最大8(相性最悪)
	 */
	int Get_相性差(int 相性値Ａ, int 相性値Ｂ);

	/*
	 * 2人の武将の相性の違いを得る。
	 * 最小0(相性最高) 最大8(相性最悪)
	 */
	int Get_武将相性差(int 武将Ａ番号【配列用】, int 武将Ｂ番号【配列用】);
}




/*
			武将名前テーブル(18*500と姫等用に18*32)

			[18バイト]
			0-6		名字
			7-13	名前
			14-15	武将ナンバー(下位12bitは列伝？)
			16	上位4ビットは身分(b0000=隠居,b0001=大名
						　b0010=2=宿老,b0011=3=家老
						　b0100=4=部将,b0101=5=侍大将
						　b0110=6=足軽頭)
				下位4ビット	0大名,1軍長,2現役,3隠居,4浪人,5姫,6?,7死亡
				
			17	性 0-男 1-女
*/
struct 武将戸籍情報型
{
	char _名字[7];	//名字
	char _名前[7];	//名前
	WORD 顔番号;	//列伝番号と一致。武将ナンバー(下位12bitは列伝？)。
					//セーブエディタやシナリオエディタの武将の｢顔番号｣と一致する。
					//「kao_24bit」や「武将一覧.xls」の番号とは１つずれる(これらは１つ大きい番号)なので注意。
	byte 状態:4;	//0大名,1軍長,2現役,3隠居,4浪人,5姫,6?,7死亡 
				    //　　状態の値を単純に変更すると、バグになるので注意。  Set_武将状態《***》を通して、武将の状態は変更可能である。
	byte 身分:4;	//身分

	byte 性別:1;	//性 0-男 1-女
	byte 退却:1;	//1:戦場で退却した。0:通常通り
	byte 戦死:1;	//1:戦場で戦死した。0:通常通り
	byte _undef:5;
};

// 以下値比較用
namespace 状態 {
	enum { 大名=0, 軍団長=1, 現役=2, 隠居=3, 浪人=4, 姫=5, /* _不明=6,*/ 死亡=7 };
};
namespace 身分 {
	enum { 隠居=0, 大名=1, 宿老=2, 家老=3, 部将=4, 侍大将=5, 足軽頭=6 };
};
namespace 性別 {
	enum { 男=0, 女=1 };
};


namespace 関数 {

	// 武将の名字を取得する
	string Get_名字( int 武将番号【配列用】);

	// 武将の名字を設定する
	void Set_名字( int 武将番号【配列用】, string 名字 );

	// 武将の名前を取得する
	string Get_名前( int 武将番号【配列用】);

	// 武将の名前を設定する
	void Set_名前( int 武将番号【配列用】, string 名前 );
}



namespace 関数 {
	// 適当な戦国時代に居そうな名字をランダムで得る。
	string Get_ランダム名字();

	// 適当な戦国時代に居そうな名前をランダムで得る。
	string Get_ランダム名前();

	// 天翔記で元々用意されてる100人の仮想姫名の中からランダムで１つを得る。
	string Get_ランダム姫名前();
}


namespace 関数 {

	// 状態::現役の武将を→状態::浪人にする。もしも、浪人化に失敗した場合はfalseが返り、成功したらtrueが返る。
	bool Set_武将状態《現役→浪人》( int 武将番号【配列用】);

	// 状態::浪人の武将を→状態::現役にする。もしも、現役化に失敗した場合はfalseが返り、成功したらtrueが返る。
	// 空白城にいる浪人は現役とはなれない。どの大名の麾下に属するべきか不明であるためである。
	bool Set_武将状態《浪人→現役》( int 武将番号【配列用】);

	// 武将の死亡処理を行う。
	// 一連のＵＩを伴った関連処理が行われるため、使用可能なタイミングが限られる関数である。注意すること。
	// 犯人武将が居ないならば、犯人武将を指定しない。(自分で死んだという形となる)
	bool Set_武将状態《→死亡》(int 死亡武将番号【配列用】, int 犯人武将番号【配列用】=-1 );

	// 特定の「現役」の武将を、その城の城主にする。
	// 元の城主が「軍団長」や「大名」だと、その人物の立場となる。
	bool Set_城主(int 武将番号【配列用】);


	// 浪人を誕生させる。通常顔番号は指定しないが、
	// 顔番号(=列伝番号)を指定すれば、その顔番号となる。
	// (列伝番号も兼ねるので、同じ顔＆列伝が複数人生存したりしないように要注意)
	// 顔番号を指定しない場合、適当に浪人が１人誕生する。
	// 返り値は、該当の浪人が誕生する際に割り当てられた「武将番号【配列用】」である。
	// 浪人作成に失敗した場合には、-1が返ってくる。
	WORD Set_武将誕生(int 顔番号 = -1);

	// 浪人と現役の武将を別の場所に転移させることが出来る。勢力を超えてどこに移動してもよい。
	// 但し、未支配城(いずれの勢力下にも属さない城)に転移すると、浪人化した状態で転移することとなる。
	bool Set_武将転居(int 武将番号【配列用】, int 転居先城番号【配列用】);
}


namespace 関数 {

	// 指定武将の「伴侶の武将番号【配列用】」得る。
	// 夫武将を指定すれば、妻武将の、
	// 妻武将を指定すれば、夫武将の武将番号【配列用】が返ってくる。
	// 伴侶が居ない人を指定した場合には、0xFFFFが返ってくる。
	int Get_伴侶武将番号【配列用】(int 武将番号【配列用】);

	// 姫(他の武将の妻含む)を、指定の武将と結婚させる、同盟関係等は一切操作されない。
	bool Set_姫結婚( int 姫武将番号【配列用】, int 夫武将番号【配列用】, BOOL 天蓋孤独死亡処理=TRUE );

	// 指定の姫を離婚させる。無事離婚して、親元や兄弟元に移動する。
	// 天蓋孤独死亡処理とは、この離婚によって、姫が天蓋孤独になってしまった(親兄弟等や、血縁の大名等が無い)場合、
	// 誰からも参照出来ない人物となり、ゲーム内で姫としての役割が不可能であるため、死亡処理を入れるというもの。
	bool Set_姫離婚( int 姫武将番号【配列用】, BOOL 天蓋孤独死亡処理=TRUE );
}


namespace 関数 {

	bool Is_自分は相手の娘( int 自分武将番号【配列用】, int 相手武将番号【配列用】 );

	bool Is_自分は相手の息子( int 自分武将番号【配列用】, int 相手武将番号【配列用】 );

	bool Is_自分は相手の子( int 自分武将番号【配列用】, int 相手武将番号【配列用】 );

	bool Is_自分は相手の親( int 自分武将番号【配列用】, int 相手武将番号【配列用】 );

	bool Is_自分は相手の父( int 自分武将番号【配列用】, int 相手武将番号【配列用】 );

	bool Is_相手は自分の父( int 自分武将番号【配列用】, int 相手武将番号【配列用】 );

	bool Is_自分は相手の母( int 自分武将番号【配列用】, int 相手武将番号【配列用】 );

	bool Is_相手は自分の母( int 自分武将番号【配列用】, int 相手武将番号【配列用】 );

	bool Is_自分は相手の弟( int 自分武将番号【配列用】, int 相手武将番号【配列用】 );

	bool Is_相手は自分の弟( int 自分武将番号【配列用】, int 相手武将番号【配列用】 );

	bool Is_自分は相手の妹( int 自分武将番号【配列用】, int 相手武将番号【配列用】 );

	bool Is_相手は自分の妹( int 自分武将番号【配列用】, int 相手武将番号【配列用】 );

	bool Is_自分は相手の兄( int 自分武将番号【配列用】, int 相手武将番号【配列用】 );

	bool Is_相手は自分の兄( int 自分武将番号【配列用】, int 相手武将番号【配列用】 );

	bool Is_自分は相手の姉( int 自分武将番号【配列用】, int 相手武将番号【配列用】 );

	bool Is_相手は自分の姉( int 自分武将番号【配列用】, int 相手武将番号【配列用】 );

	// 自分=兄、相手=弟、の順で引数として渡す
	bool Is_自分と相手は兄弟( int 自分武将番号【配列用】, int 相手武将番号【配列用】 );

	// 自分=姉、相手=妹、の順で引数として渡す
	bool Is_自分と相手は姉妹( int 自分武将番号【配列用】, int 相手武将番号【配列用】 );

	// 自分=姉、相手=弟、の順で引数として渡す
	bool Is_自分と相手は姉弟( int 自分武将番号【配列用】, int 相手武将番号【配列用】 );

	// 自分=兄、相手=妹、の順で引数として渡す
	bool Is_自分と相手は兄妹( int 自分武将番号【配列用】, int 相手武将番号【配列用】 );

	bool Is_自分は相手の夫( int 自分武将番号【配列用】, int 相手武将番号【配列用】 );

	bool Is_自分は相手の妻( int 自分武将番号【配列用】, int 相手武将番号【配列用】 );

	bool Is_自分は相手の血縁( int 自分武将番号【配列用】, int 相手武将番号【配列用】 );

	// 自分が大名で、相手は家臣という関係かどうか
	bool Is_相手は自分の家臣( int 自分武将番号【配列用】, int 相手武将番号【配列用】 );

	bool Is_相手は自分の大名( int 自分武将番号【配列用】, int 相手武将番号【配列用】 );

	// 家臣はもちろん、大名自身も自分の大名家に所属しているとみなされる。
	bool Is_自分と相手は同じ大名家所属( int 自分武将番号【配列用】, int 相手武将番号【配列用】 );

}