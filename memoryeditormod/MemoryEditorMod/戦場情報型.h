/*
 * 武将情報型 及び、 武将戸籍情報型
 */
#pragma once
#pragma pack(1)

#include <windows.h>
#include <vector>

#include "２Ｄ位置情報型.h"
#include "３Ｄ位置情報型.h"

using namespace std;




//-------------戦争の大枠判定---------------------------------------------------------------

struct 戦争開始パラメタ型 {
	int 城番号;						// 標的の城番号
	int 守備側軍団【軍団番号】;		// 守備側の軍団番号
	int 守備側軍団長【武将番号】;	// 守備側の軍団長の武将番号
	int 攻撃側軍団【軍団番号】;		// 攻めた側の軍団番号
	int 攻撃側軍団長【武将番号】;	// 攻めた側の軍団長の武将番号
};




namespace 参戦立場 { 
	enum { 不明 = 0, 攻撃軍 = 1, 守備軍=2, 攻撃の援軍 = 3, 守備の援軍 = 4, 中立軍 = 5 };
};


namespace 混乱状態 {
	enum { 無し = 0, 混乱 = 1, 大混乱 = 2, 挑発 = 3 };
}


namespace 関数 {
	// 現在進行中の戦争に関わっているiDaimyoIDのリスト。(出陣しているかどうかは関係ない)
	番号リスト型 Get_参戦の大名番号リスト【配列用】();

	// 現在進行中の戦争に関わっているiGundanIDのリスト。(出陣しているかどうかは関係ない)
	番号リスト型 Get_参戦の軍団番号リスト【配列用】();


	// 該当の軍団の戦場における立場を返す(不明=0, 直接攻める側=1, 直接守る側=2, 攻める側の援軍=3, 守る側の援軍=4, 中立軍=5)
	int Get_軍団の参戦立場(int 軍団番号【配列用】);

	// 該当の武将の戦場における立場を返す(不明=0, 直接攻める側=1, 直接守る側=2, 攻める側の援軍=3, 守る側の援軍=4, 中立軍=5)
	int Get_武将の参戦立場(int 武将番号【配列用】);

	// 現在の戦において、指定軍団の大将(軍団長や大名のことではなく、戦場においての指定軍団の代表者)
	int Get_参戦軍団の指揮者(int 軍団番号【配列用】);
}







namespace 関数 {

	bool Is_野戦中();          // 現在画面に出てる戦場は、野戦

	bool Is_攻城戦中();        // 現在画面に出てる戦場は、攻城戦

	WORD Get_攻城戦中の城番号(); // 現在画面に出てて攻城中の城番号。0xFFFFなら城を攻城中ではなく、野戦中。だが、それはIs_野戦中で判定すれば良い。

	int Get_戦争残りターン数();	// 戦争残りターン数を得る
	int Get_攻城戦ターン数();	// 現在表示中の攻城戦のターン数（１〜３）。攻城戦ではない場合は、-1が返ってくる。

	// 死亡者や退却者も含み、
	番号リスト型 Get_武将番号リスト【配列用】();

	// 現在の戦域全域を対象として出陣している武将番号配列用のリストを得る。
	番号リスト型 Get_出陣中の武将番号リスト【配列用】();

	// 現在表示中の戦闘マップに出陣している武将番号配列用のリストを得る。
	番号リスト型 Get_出陣中の武将番号リスト【配列用】《表示中マップ》();

	// 戦場において、該当の武将は、既に行動済みである。
	// 行動済みならTRUEが、未行動ならFALSEが返ってくる。
	bool Is_武将行動済《戦争画面》(int 武将番号【配列用】);


	// 戦場において、該当の武将は混乱している。
	int Get_武将混乱状態(int 武将番号【配列用】);

	// 戦場において、該当の武将を混乱させる。
	bool Set_武将混乱状態(int 武将番号【配列用】, int 混乱状態);


	// 戦場において、該当の武将は大混乱している。
	bool Is_武将大混乱(int 武将番号【配列用】);

	int Get_移動残量(int 武将番号【配列用】);

	int Get_行動団体帰属(int 武将番号【配列用】);

	// 大混乱や混乱など武将のユニットの描画更新
	void 武将ユニット状態描画更新《戦争画面》(int 武将番号【配列用】);

}



//-------------戦争のヘックス位置やヘックス情報関連---------------------------------------------------------------

namespace 野戦ヘックス {
	const int 中心Ｘ = 20;
	const int 中心Ｙ = 12;
}
namespace 攻城戦ヘックス {
	const int 中心Ｘ = 9;
	const int 中心Ｙ = 8;
}


// ヘックスの座標軸系。Ｘ→ Ｙ↓　で値が増加していく。
struct ヘックス位置型 {
	ヘックス位置型(double Ｘ位置, double Ｙ位置) : Ｘ(Ｘ位置),Ｙ(Ｙ位置) {}
	ヘックス位置型() : Ｘ(0),Ｙ(0) {}
	double Ｘ;
	double Ｙ;
};

// フィールドの方向ベクトル。Ｘ→ Ｙ↓　で値が増加していく。
struct ヘックスベクトル型 {
	ヘックスベクトル型(double Ｘ成分, double Ｙ成分) : Ｘ(Ｘ成分),Ｙ(Ｙ成分) {}
	ヘックスベクトル型() : Ｘ(0),Ｙ(0) {}
	double Ｘ;
	double Ｙ;
};


namespace 関数 {
	// ＨＥＸ位置同志の減算。座標Ａ→座標Ｂのベクトルを求めるのに、通常、Ｂ−Ａをするだろうから。
	ヘックスベクトル型 operator-(ヘックス位置型 &p1, ヘックス位置型 &p2);
}


namespace 野戦ヘックス役割 {
	enum { 枠外=0x00, 平地=0x1, 道=0x2, 湿地=0x3, 荒れ地=0x4, 森=0x5, 低山=0x6, 中山=0x7, 高山=0x8, 川=0x9, 橋=0xA, 海=0xB, 湖=0xB, 城=0xC /*２個連続*/};
}
namespace 攻城戦ヘックス役割 {
	enum { 枠外=0x00, 城内平地=0x10 , 城内整地=0x11, 城外平地=0x12, 森=0x13, 堀=0x14, 海=0x14, 湖=0x14, 堀橋=0x15, 城壁=0x16, 閉門=0x17, 開門=0x18, 櫓=0x19, 柵=0x1A, 本丸=0x1B };
}

namespace 関数 {

	// ある野戦で、指定座標のチップの役割(攻城戦ヘックス役割)を得る
	int Get_野戦ヘックス役割(double Ｘ位置, double Ｙ位置);
	int Get_野戦ヘックス役割(ヘックス位置型 Ｐ);

	// ある攻城戦で、指定座標のチップの役割(野戦ヘックス役割)を得る
	int Get_攻城戦ヘックス役割(double Ｘ位置, double Ｙ位置);
	int Get_攻城戦ヘックス役割(ヘックス位置型 Ｐ) ;

	// ある攻城戦で、指定座標のチップの高さを得る。(城は城壁で囲まれていて、何層かに高さが設定されている)
	int Get_攻城戦ヘックス高さ(double Ｘ位置, double Ｙ位置);
	int Get_攻城戦ヘックス高さ(ヘックス位置型 Ｐ);

	// ヘックス間隔の取得。Ｐ１→Ｐ２まで何マス移動する必要があるのか(全てのマスは行けるものと仮定する)
	int Get_ヘックス間隔( ヘックス位置型 Ｐ１, ヘックス位置型 Ｐ２ );

	// 指定の武将ＩＤの武将がどこにいるのか？ 表示中のマップに居ない場合、Ｐ(x=0xFFFF, y=0xFFFF) が返ってくる。
	ヘックス位置型 Get_武将の野戦ヘックス位置(int 武将番号【配列用】);

	// 指定の武将ＩＤの武将がどこにいるのか？ 表示中のマップに居ない場合、Ｐ(x=0xFFFF, y=0xFFFF) が返ってくる。
	ヘックス位置型 Get_武将の攻城戦ヘックス位置(int 武将番号【配列用】);

	// ２点間座標の差
	ヘックスベクトル型 operator-(ヘックス位置型 &p1, ヘックス位置型 &p2);

	// 野戦ヘックスの座標→普通の３次元座標(左手デカルト・音と同じへ)
	３Ｄ位置型 野戦ヘックス位置→３Ｄ位置(ヘックス位置型 Ｐ);

	// 普通の３次元座標(左手デカルト)→フィールドヘックスの座標へ
	ヘックス位置型 ３Ｄ位置→野戦ヘックス位置(３Ｄ位置型 Ｐ);

	// 攻城戦ヘックスの座標→普通の３次元座標(左手デカルト・音と同じへ)
	３Ｄ位置型 攻城戦ヘックス位置→３Ｄ位置(ヘックス位置型 Ｐ);

	// 普通の３次元座標(左手デカルト)→城ヘックスの座標へ
	ヘックス位置型 ３Ｄ位置→攻城戦ヘックス位置(３Ｄ位置型 Ｐ);
}



